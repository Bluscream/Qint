<#@ output extension=".cs" #>
<#@ template debug="true" hostSpecific="true" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#= "// *** DO NOT EDIT THIS FILE, IT HAS BEEN AUTO-GENERATED ***" #>

using System;
using System.Runtime.InteropServices;
using u8 = System.Byte;
using u16 = System.UInt16;
using u32 = System.UInt32;
using u64 = System.UInt64;
using i8 = System.SByte;
using i16 = System.Int16;
using i32 = System.Int32;
using i64 = System.Int64;
using f32 = System.Single;
using f64 = System.Double;
using str = System.String;

using ServerId = System.UInt64;
using ConnectionId = System.UInt64;
using ClientUid = System.String;
using ClientDbId = System.UInt64;
using ClientId = System.UInt16;
using ChannelId = System.UInt64;
using ServerGroupId = System.UInt64;
using ChannelGroupId = System.UInt64;
using TimeSpanSeconds = System.TimeSpan;
using TimeSpanMillisec = System.TimeSpan;

#pragma warning disable IDE1006

namespace Qint.Wrapper.Dto
{
<#
const string dllName = "tslib";
const string regParamCore = @"\s*(?<param>\s*(?<pname>(get|set|doc|id|optional))\s*:\s*(?<pval>(?:\w+|""(?>[^""]|[""\\n])*""|\[[^]]*\]))\s*,?)*";
const string regParam = @"(?:;" + regParamCore + @")?";
string declFilePath = Host.ResolvePath("BookDeclarations.txt");
string[] declLines = File.ReadAllLines(declFilePath);
	
var structList = new List<Struct>();
var propList = new List<Prop>();
var nestList = new List<Values>();
	
string pstruct = null;
Values defaults = new Values();

foreach(var line in declLines)
{
	if(string.IsNullOrWhiteSpace(line))
		continue;

	var parts = line.Split(new [] {':'}, 2);
	if(parts.Length < 2 || string.IsNullOrWhiteSpace(parts[0]))
		continue;

	void Fill(Match data, Values val) {
		//if(!data.Groups["param"].Success) return;
		for(int i = 0; i < data.Groups["pname"].Captures.Count; i++) {
			var kval = data.Groups["pval"].Captures[i].Value.Trim();
			switch(data.Groups["pname"].Captures[i].Value.ToLower()) {
				case "doc": val.doc = kval; break;
				case "get": val.pget = bool.Parse(kval); break;
				case "set": val.pset = bool.Parse(kval); break;
				case "id": val.id = kval; break;
				case "optional": val.optional = bool.Parse(kval); break;
				//case "struct": val.pstruct = kval; break;
			}
		}
	}

	parts[0] = parts[0].Trim().ToUpper();
	switch(parts[0]) 
	{
	case "STRUCT": {
		var data = Regex.Match(parts[1], @"\s*(?<name>\w+)\s*" + regParam);
		if(!data.Success) throw new Exception("No match: " + line);
			
		var val = new Values();
		var struc = new Struct() { name = data.Groups["name"].Value, values = val};
		pstruct = struc.name;
		structList.Add(struc);
		Fill(data, val);

		break; }

	case "PROP": {
		var data = Regex.Match(parts[1], @"\s*(?<name>\w+)\s*,\s*(?<type>\w+)\s*" + regParam);
		if(!data.Success) throw new Exception("No match: " + line);

		var val = new Values();
		var prop = new Prop() { name = data.Groups["name"].Value, type = data.Groups["type"].Value, values = val, struc = pstruct};
		propList.Add(prop);
		val.Copy(defaults);
		Fill(data, val);

		break; }
			
	case "DEFAULT": {
		var data = Regex.Match(parts[1], regParamCore);
		if(!data.Success) throw new Exception("No match: " + line);

		defaults = new Values();
		Fill(data, defaults);
		//Write("//" + defaults + "\n");

		break; }

	case "NESTED": {

		break; }
			
	case "": continue;
	default: throw new Exception("Unknown Entry:" + line);
	}
}
	
string ToSnake(string x) => Regex.Replace(x, "([A-Z])", "_$0").TrimStart('_').ToLower();
string ToPascal(string x) => string.Concat(x.Split('_').Where(s => s.Length > 0).Select(s => char.ToUpper(s[0]) + s.Substring(1)));
string Unquote(string x) => (!x.StartsWith("\"") || !x.EndsWith("\"")) ? x : x.Substring(1, x.Length - 2).Replace("\\n", "\n").Replace("\\\"", "\"").Replace("\\\\", "\\");
string ToDoc(string x) => $@"///<summary>{x}</summary>".Replace("\n", " ");
Prop Find(string id) {
	var parts = id.Split('.');
	return propList.First(x => x.struc == parts[0] && x.name == parts[1]);
}

foreach(var struc in structList)
{
	if(struc.values.doc != null)
		WriteLine("\t" + ToDoc(Unquote(struc.values.doc)));
	Write($"\tpublic sealed class {struc.name}\n\t{{\n");

	Prop[] ids;
	string para;
	string paraCom;
	string paraVal;
	string paraValCom;
	if(struc.values.id != null)
	{
		ids = struc.values.id.TrimStart('[').TrimEnd(']').Split(new []{" "}, StringSplitOptions.RemoveEmptyEntries).Select(x => x.Trim()).Select(Find).ToArray();
		para = string.Join(", ", ids.Select(prop => $"{prop.type} {prop.struc}{prop.name}"));
		paraVal = string.Join(", ", ids.Select(prop => $"{prop.struc}{prop.name}"));
		paraCom = para + ", ";
		paraValCom = paraVal + ", ";

		WriteLine($"\t\tpublic {struc.name}({para})\n\t\t{{");
		foreach(var prop in ids)
			WriteLine($"\t\t\tthis.{prop.struc}{prop.name} = this.{prop.struc}{prop.name};");
		WriteLine($"\t\t}}");
		
		foreach(var prop in ids) {
			if(prop.values.doc != null)
				WriteLine("\t\t" + ToDoc(Unquote(prop.values.doc)));
			WriteLine($"\t\tpublic {prop.type} {prop.struc}{prop.name} {{ get; }}");
		}
		WriteLine("");
	}
	else 
	{
		ids = new Prop[0];
		para = "";
		paraCom = "";
		paraVal = "";
		paraValCom = "";
	}

	foreach(var prop in propList)
	{
		if(prop.struc != struc.name) continue;
		if(ids.Any(x => x.struc == prop.struc && x.name == prop.name)) continue;
		if(!prop.values.pget.HasValue || !prop.values.pset.HasValue) throw new Exception("no get or set");
		if(!prop.values.pget.Value && !prop.values.pset.Value) continue;

		string getstr = null;
		if(prop.values.pget.Value) {
			getstr = $"get_{ToSnake(struc.name)}_{ToSnake(prop.name)}";
			Write($"\t\t[DllImport(\"{dllName}\")] private static extern {prop.type} {getstr}({para});\n");
		}
		string setstr = null;
		if(prop.values.pset.Value) {
			setstr = $"set_{ToSnake(struc.name)}_{ToSnake(prop.name)}";
			Write($"\t\t[DllImport(\"{dllName}\")] private static extern {prop.type} {setstr}({paraCom}{prop.type} {prop.name});\n");
		}

		if(prop.values.doc != null)
			WriteLine("\t\t" + ToDoc(Unquote(prop.values.doc)));
		Write($"\t\tpublic {prop.type} {prop.name} {{ ");
		if(prop.values.pget.Value)
			Write($"get => {getstr}({paraVal}); ");
		if(prop.values.pset.Value)
			Write($"set => {setstr}({paraValCom}value); ");
		Write($"}}\n");
	}

	Write($"\t}}\n\n");
}
#>
}

#pragma warning restore IDE1006

<#+
class Values
{
	public string doc;
	public bool? pget;
	public bool? pset;
	public string id;
	public bool? optional;

	public void Copy(Values o) { 
		doc = o.doc ?? doc;
		pget = o.pget ?? pget;
		pset = o.pset ?? pset;
		id = o.id ?? id;
		optional = o.optional ?? optional;
	}

	public override string ToString() => $"g:{pget} s:{pset} id:{id} opt:{optional} doc:{doc}";
}
class Prop
{
	public string name;
	public string type;
	public string struc;
	public Values values;
}
class Struct
{
	public string name;
	public Values values;
}
#>